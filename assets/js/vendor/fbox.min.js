var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, {get: all[name2], enumerable: true});
};

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (var i2 = 0; i2 < 256; ++i2) {
  byteToHex.push((i2 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i2 = 0; i2 < 16; ++i2) {
      buf[offset + i2] = rnds[i2];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// lib/sch/type.js
var RECORD = "record";
var LIST = "list";
var TUPLE = "tuple";
var STRING = "string";
var NUMBER = "number";
var INTEGER = "integer";
var BOOLEAN = "boolean";
var NULL = "null";
var UNION = "union";
var ANY = "any";
var REF = "ref";
var VALUE = "value";
var CONTAINER_TYPES = [RECORD, TUPLE, LIST, UNION];
var FMODEL_BOX = "fmodel";
var any = () => ({type: ANY});
var string = () => ({type: STRING});
var bool = () => ({type: BOOLEAN});
var number = () => ({type: NUMBER});
var nil = () => ({type: NULL});
var record = () => ({type: RECORD, fields: {}, order: []});
var list = () => ({type: LIST, sch: putAnchor(any)});
var tuple = () => ({type: TUPLE, schs: [putAnchor(any)]});
var union = () => ({type: UNION, schs: [putAnchor(any)]});
var ref = (anchor) => ({type: REF, $ref: anchor});
var value = (v) => {
  try {
    v = JSON.parse(v);
    if (v == null || [STRING, NUMBER, BOOLEAN].includes(typeof v))
      return {type: VALUE, const: v};
    else
      return false;
  } catch (e) {
    return false;
  }
};
var putAnchor = (sch, box, opts = {force: false}) => {
  let newSch = sch();
  newSch.$anchor || (newSch.$anchor = v4_default());
  if (opts.force)
    newSch.$anchor = v4_default();
  return newSch;
};

// lib/sch.js
var clone = (obj) => {
  let sch = JSON.parse(JSON.stringify(obj));
  walk(sch, (a, m) => putAnchor(() => a, null, {force: true}));
  return sch;
};
var walk = (sch, f, meta = {path: "", level: 1, parent: {}}) => {
  sch._halt = false;
  sch = f(sch, meta);
  if (sch._halt)
    return sch;
  switch (true) {
    case [RECORD].includes(sch.type):
      let keys = Object.keys(sch.fields);
      for (let i2 = keys.length - 1; i2 >= 0; i2--) {
        let k = keys[i2];
        let sch_2 = sch.fields[k];
        let nextMeta2 = {path: `${meta.path}[${k}]`, level: meta.level + 1, parent: {_box: sch._box, type: sch.type}};
        sch_2 = walk(sch_2, f, nextMeta2);
        sch_2.key = k;
        sch.fields[k] = sch_2;
        if (sch_2._halt)
          return Object.assign(sch, {_halt: true});
      }
      break;
    case [TUPLE, UNION].includes(sch.type):
      for (let i2 = 0; i2 < sch.schs.length; i2++) {
        let sch_2 = sch.schs[i2];
        let nextMeta2 = {path: `${meta.path}[][${i2}]`, level: meta.level + 1, parent: {_box: sch._box, type: sch.type}};
        sch_2 = walk(sch_2, f, nextMeta2);
        sch.schs[i2] = sch_2;
        if (sch_2._halt)
          return Object.assign(sch, {_halt: true});
      }
      break;
    case [LIST].includes(sch.type):
      let nextMeta = {path: `${meta.path}[][0]`, level: meta.level + 1, parent: {_box: sch._box, type: sch.type}};
      let sch_ = walk(sch.sch, f, nextMeta);
      sch.sch = sch_;
      if (sch_._halt)
        return Object.assign(sch, {_halt: true});
      break;
    default:
      sch;
  }
  return sch;
};
var pop = (schema, path, indices) => {
  let result = {original: {}, popped: []};
  let descIndices = indices.sort((a, b) => b - a);
  walk(schema, (sch_, meta) => {
    if (meta.path != path)
      return sch_;
    else {
      switch (sch_.type) {
        case RECORD:
          let ikeys = descIndices.map((i2) => [i2, sch_.order[i2]]).filter(([i2, k]) => k);
          for (let [i2, k] of ikeys) {
            result.popped.unshift({k, sch: sch_.fields[k], index: i2});
            delete sch_.fields[k];
          }
          for (let i2 of descIndices)
            sch_.order.splice(i2, 1);
          break;
        case LIST:
          break;
        case TUPLE:
          for (let i2 of descIndices)
            result.popped.unshift({k: i2, sch: sch_.schs.splice(i2, 1)[0], index: i2});
          if (sch_.schs.length == 0)
            sch_.schs.splice(0, 0, putAnchor(any));
          break;
        case UNION:
          for (let i2 of descIndices)
            result.popped.unshift({k: i2, sch: sch_.schs.splice(i2, 1)[0], index: i2});
          if (sch_.schs.length == 0)
            sch_.schs.splice(0, 0, putAnchor(any));
          break;
        default:
          sch_;
      }
      return sch_;
    }
  });
  return result;
};
var filterMostOuters = (paths) => {
  return paths.filter((p) => {
    for (let p_ of paths) {
      if (p == p_)
        return true;
      else if (p.startsWith(p_))
        return false;
    }
  });
};
var put = (schema, path, rawSchs) => {
  let result = {original: {}, inserted: []};
  let ascRawSchs = rawSchs.sort((a, b) => a.index - b.index);
  const boundIndex = (index, arr) => {
    index = Math.max(index, 0);
    index = Math.min(index, arr.length);
    return index;
  };
  walk(schema, (sch_, meta) => {
    if (meta.path != path)
      return sch_;
    else {
      switch (sch_.type) {
        case RECORD:
          for (let {k, sch, index} of ascRawSchs) {
            k = k == 0 ? "0" : k;
            k = k || `key_${Math.floor(Date.now() / 100)}`;
            k = `${k}`;
            while (sch_.fields[k])
              k = `${k} \u2013`;
            index = boundIndex(index, sch_.order);
            sch_.fields[k] = putAnchor(sch, sch_._box);
            sch_.order.splice(index, 0, k);
            result.inserted.push({k, sch: sch_.fields[k], index});
          }
          break;
        case LIST:
          break;
        case TUPLE:
          for (let {k, sch, index} of ascRawSchs) {
            index = boundIndex(index, sch_.schs);
            sch_.schs.splice(index, 0, putAnchor(sch, sch_._box));
            result.inserted.push({k, sch: sch_.schs[index], index});
          }
          break;
        case UNION:
          for (let {k, sch, index} of ascRawSchs) {
            index = boundIndex(index, sch_.schs);
            sch_.schs.splice(index, 0, putAnchor(sch, sch_._box));
            result.inserted.push({k, sch: sch_.schs[index], index});
          }
        default:
          sch_;
      }
      return sch_;
    }
  });
  return result;
};
var move = (store, {dstPath, startIndex = 0}, selectedPerParent) => {
  const pinDst = (store2, dstPath2, pin2) => update(store2, dstPath2, (a, m) => {
    a._pinId = pin2;
    return a;
  });
  let pin = Symbol(dstPath);
  pinDst(store, dstPath, pin);
  let poppedPerSrc = popToRawSchs(store, selectedPerParent, {dstPath});
  let moved = putPoppedRawSchs(store, {dstPin: pin, startIndex}, poppedPerSrc);
  return moved;
};
var popToRawSchs = (store, selectedPerParent, opts = {}) => {
  let poppedPerSrc = {};
  const srcPaths = filterMostOuters(Object.keys(selectedPerParent));
  for (let srcPath of srcPaths) {
    let selectedItems = selectedPerParent[srcPath];
    const newK = (index) => {
      var _a;
      return (_a = selectedItems.find((c) => c.index == index)) == null ? void 0 : _a.newK;
    };
    if (opts.dstPath) {
      let isDstSubtree = selectedItems.filter((c) => opts.dstPath.startsWith(c.id)).length != 0;
      if (isDstSubtree)
        continue;
    }
    let result = pop(store, srcPath, selectedItems.map((c) => c.index));
    let rawSchs = result.popped.map(({k, sch, index}) => {
      return {k: newK(index) || k, sch: () => sch};
    });
    poppedPerSrc[srcPath] = rawSchs;
  }
  return poppedPerSrc;
};
var putPoppedRawSchs = (store, {dstPin, dstPath, startIndex = 0}, poppedPerSrc) => {
  const getPinedDst = (store2, pin) => getByAndUpdate(store2, (a, m) => a._pinId == pin, (a, m) => {
    a._pinned = m;
    return a;
  });
  startIndex = Math.max(startIndex, 0);
  let moved = {};
  let rawSchs = Object.values(poppedPerSrc).flatMap((popped) => popped).map((raw, i2) => {
    return {...raw, index: startIndex + i2};
  });
  if (dstPin) {
    let dst = getPinedDst(store, dstPin);
    if (dst)
      dstPath = dst._pinned.path;
  }
  let result_ = put(store, dstPath, rawSchs);
  if (result_.inserted.length != 0)
    moved[dstPath] = result_.inserted;
  return moved;
};
var putSelected = (store, {dstPath, startIndex = 0}, selectedPerParent) => {
  let rawSchs = copyToRawSchs(store, selectedPerParent, {dstPath, startIndex});
  let pasted = putSelectedRawSchs(store, {dstPath}, rawSchs);
  return pasted;
};
var copyToRawSchs = (store, selectedPerParent, opts = {}) => Object.values(selectedPerParent).reduce((acc, cc) => {
  let ids = cc.map((c) => c.id);
  let collector = [];
  getByAndUpdate(store, (a, m) => {
    if (ids.includes(m.path)) {
      a._meta = m;
      collector.unshift(a);
    }
    if (collector.length == ids.length)
      return true;
    return false;
  }, (a, m) => a);
  for (let c of cc) {
    if (opts.dstPath && opts.dstPath.startsWith(c.id))
      continue;
    let sch = collector.find((a) => a._meta.path == c.id);
    if (sch)
      acc.unshift({k: c.key, sch: () => clone(sch), index: opts.startIndex + acc.length, id: c.id});
  }
  return acc;
}, []);
var putSelectedRawSchs = (store, {dstPath}, rawSchs) => {
  let pasted = {};
  let result_ = put(store, dstPath, rawSchs);
  if (result_.inserted.length != 0)
    pasted[dstPath] = result_.inserted;
  return pasted;
};
var changeType = (store, path, sch) => update(store, path, (a, m) => {
  let newSch = putAnchor(sch, m.parent._box);
  switch (true) {
    case newSch.type == REF:
    case newSch.type == VALUE:
    case newSch.type != a.type:
      let {title, description, rw, required, $anchor} = a;
      Object.assign(newSch, {title, description, rw, required, $anchor});
      return newSch;
    default:
      return a;
  }
});
var get = (currentNode, path) => getByAndUpdate(currentNode, (a, m) => m.path == path, (a, m) => {
  a._meta = m;
  return a;
});
var update = (currentNode, path, fupdate) => getByAndUpdate(currentNode, (a, m) => m.path == path, fupdate);
var getByAndUpdate = (currentNode, fget, fupdate) => {
  let foundSch;
  walk(currentNode, (sch_, meta) => {
    if (fget(sch_, meta)) {
      foundSch = fupdate(sch_, meta);
      foundSch._halt = true;
      return foundSch;
    } else
      return sch_;
  });
  if (foundSch)
    foundSch._halt = false;
  return foundSch;
};

// node_modules/umap/esm/index.js
var esm_default = (_) => ({
  get: (key) => _.get(key),
  set: (key, value2) => (_.set(key, value2), value2)
});

// node_modules/uparser/esm/index.js
var attr = /([^\s\\>"'=]+)\s*=\s*(['"]?)$/;
var empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;
var node = /<[a-z][^>]+$/i;
var notNode = />[^<>]*$/;
var selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\/>)/ig;
var trimEnd = /\s+$/;
var isNode = (template, i2) => 0 < i2-- && (node.test(template[i2]) || !notNode.test(template[i2]) && isNode(template, i2));
var regular = (original, name2, extra) => empty.test(name2) ? original : `<${name2}${extra.replace(trimEnd, "")}></${name2}>`;
var esm_default2 = (template, prefix2, svg2) => {
  const text2 = [];
  const {length} = template;
  for (let i2 = 1; i2 < length; i2++) {
    const chunk = template[i2 - 1];
    text2.push(attr.test(chunk) && isNode(template, i2) ? chunk.replace(attr, (_, $1, $2) => `${prefix2}${i2 - 1}=${$2 || '"'}${$1}${$2 ? "" : '"'}`) : `${chunk}<!--${prefix2}${i2 - 1}-->`);
  }
  text2.push(template[length - 1]);
  const output = text2.join("").trim();
  return svg2 ? output : output.replace(selfClosing, regular);
};

// node_modules/uarray/esm/index.js
var {isArray} = Array;
var {indexOf, slice} = [];

// node_modules/uwire/esm/index.js
var ELEMENT_NODE = 1;
var nodeType = 111;
var remove = ({firstChild, lastChild}) => {
  const range = document.createRange();
  range.setStartAfter(firstChild);
  range.setEndAfter(lastChild);
  range.deleteContents();
  return firstChild;
};
var diffable = (node2, operation) => node2.nodeType === nodeType ? 1 / operation < 0 ? operation ? remove(node2) : node2.lastChild : operation ? node2.valueOf() : node2.firstChild : node2;
var persistent = (fragment) => {
  const {childNodes} = fragment;
  const {length} = childNodes;
  if (length < 2)
    return length ? childNodes[0] : fragment;
  const nodes = slice.call(childNodes, 0);
  const firstChild = nodes[0];
  const lastChild = nodes[length - 1];
  return {
    ELEMENT_NODE,
    nodeType,
    firstChild,
    lastChild,
    valueOf() {
      if (childNodes.length !== length) {
        let i2 = 0;
        while (i2 < length)
          fragment.appendChild(nodes[i2++]);
      }
      return fragment;
    }
  };
};

// node_modules/udomdiff/esm/index.js
var esm_default3 = (parentNode, a, b, get2, before) => {
  const bLength = b.length;
  let aEnd = a.length;
  let bEnd = bLength;
  let aStart = 0;
  let bStart = 0;
  let map = null;
  while (aStart < aEnd || bStart < bEnd) {
    if (aEnd === aStart) {
      const node2 = bEnd < bLength ? bStart ? get2(b[bStart - 1], -0).nextSibling : get2(b[bEnd - bStart], 0) : before;
      while (bStart < bEnd)
        parentNode.insertBefore(get2(b[bStart++], 1), node2);
    } else if (bEnd === bStart) {
      while (aStart < aEnd) {
        if (!map || !map.has(a[aStart]))
          parentNode.removeChild(get2(a[aStart], -1));
        aStart++;
      }
    } else if (a[aStart] === b[bStart]) {
      aStart++;
      bStart++;
    } else if (a[aEnd - 1] === b[bEnd - 1]) {
      aEnd--;
      bEnd--;
    } else if (a[aStart] === b[bEnd - 1] && b[bStart] === a[aEnd - 1]) {
      const node2 = get2(a[--aEnd], -1).nextSibling;
      parentNode.insertBefore(get2(b[bStart++], 1), get2(a[aStart++], -1).nextSibling);
      parentNode.insertBefore(get2(b[--bEnd], 1), node2);
      a[aEnd] = b[bEnd];
    } else {
      if (!map) {
        map = new Map();
        let i2 = bStart;
        while (i2 < bEnd)
          map.set(b[i2], i2++);
      }
      if (map.has(a[aStart])) {
        const index = map.get(a[aStart]);
        if (bStart < index && index < bEnd) {
          let i2 = aStart;
          let sequence = 1;
          while (++i2 < aEnd && i2 < bEnd && map.get(a[i2]) === index + sequence)
            sequence++;
          if (sequence > index - bStart) {
            const node2 = get2(a[aStart], 0);
            while (bStart < index)
              parentNode.insertBefore(get2(b[bStart++], 1), node2);
          } else {
            parentNode.replaceChild(get2(b[bStart++], 1), get2(a[aStart++], -1));
          }
        } else
          aStart++;
      } else
        parentNode.removeChild(get2(a[aStart++], -1));
    }
  }
  return b;
};

// node_modules/uhandlers/esm/index.js
var aria = (node2) => (values) => {
  for (const key in values) {
    const name2 = key === "role" ? key : `aria-${key}`;
    const value2 = values[key];
    if (value2 == null)
      node2.removeAttribute(name2);
    else
      node2.setAttribute(name2, value2);
  }
};
var attribute = (node2, name2) => {
  let oldValue, orphan = true;
  const attributeNode = document.createAttributeNS(null, name2);
  return (newValue) => {
    if (oldValue !== newValue) {
      oldValue = newValue;
      if (oldValue == null) {
        if (!orphan) {
          node2.removeAttributeNode(attributeNode);
          orphan = true;
        }
      } else {
        attributeNode.value = newValue;
        if (orphan) {
          node2.setAttributeNodeNS(attributeNode);
          orphan = false;
        }
      }
    }
  };
};
var boolean = (node2, key, oldValue) => (newValue) => {
  if (oldValue !== !!newValue) {
    if (oldValue = !!newValue)
      node2.setAttribute(key, "");
    else
      node2.removeAttribute(key);
  }
};
var data = ({dataset}) => (values) => {
  for (const key in values) {
    const value2 = values[key];
    if (value2 == null)
      delete dataset[key];
    else
      dataset[key] = value2;
  }
};
var event = (node2, name2) => {
  let oldValue, type = name2.slice(2);
  if (!(name2 in node2) && name2.toLowerCase() in node2)
    type = type.toLowerCase();
  return (newValue) => {
    const info = isArray(newValue) ? newValue : [newValue, false];
    if (oldValue !== info[0]) {
      if (oldValue)
        node2.removeEventListener(type, oldValue, info[1]);
      if (oldValue = info[0])
        node2.addEventListener(type, oldValue, info[1]);
    }
  };
};
var ref2 = (node2) => (value2) => {
  if (typeof value2 === "function")
    value2(node2);
  else
    value2.current = node2;
};
var setter = (node2, key) => key === "dataset" ? data(node2) : (value2) => {
  node2[key] = value2;
};
var text = (node2) => {
  let oldValue;
  return (newValue) => {
    if (oldValue != newValue) {
      oldValue = newValue;
      node2.textContent = newValue == null ? "" : newValue;
    }
  };
};

// node_modules/@ungap/create-content/esm/index.js
/*! (c) Andrea Giammarchi - ISC */
var createContent = function(document2) {
  "use strict";
  var FRAGMENT = "fragment";
  var TEMPLATE = "template";
  var HAS_CONTENT = "content" in create2(TEMPLATE);
  var createHTML = HAS_CONTENT ? function(html2) {
    var template = create2(TEMPLATE);
    template.innerHTML = html2;
    return template.content;
  } : function(html2) {
    var content = create2(FRAGMENT);
    var template = create2(TEMPLATE);
    var childNodes = null;
    if (/^[^\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html2)) {
      var selector = RegExp.$1;
      template.innerHTML = "<table>" + html2 + "</table>";
      childNodes = template.querySelectorAll(selector);
    } else {
      template.innerHTML = html2;
      childNodes = template.childNodes;
    }
    append(content, childNodes);
    return content;
  };
  return function createContent2(markup, type) {
    return (type === "svg" ? createSVG : createHTML)(markup);
  };
  function append(root, childNodes) {
    var length = childNodes.length;
    while (length--)
      root.appendChild(childNodes[0]);
  }
  function create2(element) {
    return element === FRAGMENT ? document2.createDocumentFragment() : document2.createElementNS("http://www.w3.org/1999/xhtml", element);
  }
  function createSVG(svg2) {
    var content = create2(FRAGMENT);
    var template = create2("div");
    template.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg">' + svg2 + "</svg>";
    append(content, template.firstChild.childNodes);
    return content;
  }
}(document);
var esm_default4 = createContent;

// node_modules/uhtml/esm/node.js
var reducePath = ({childNodes}, i2) => childNodes[i2];
var createPath = (node2) => {
  const path = [];
  let {parentNode} = node2;
  while (parentNode) {
    path.push(indexOf.call(parentNode.childNodes, node2));
    node2 = parentNode;
    parentNode = node2.parentNode;
  }
  return path;
};
var {createTreeWalker, importNode} = document;
var isImportNodeLengthWrong = importNode.length != 1;
var createFragment = isImportNodeLengthWrong ? (text2, type, normalize) => importNode.call(document, esm_default4(text2, type, normalize), true) : esm_default4;
var createWalker = isImportNodeLengthWrong ? (fragment) => createTreeWalker.call(document, fragment, 1 | 128, null, false) : (fragment) => createTreeWalker.call(document, fragment, 1 | 128);

// node_modules/uhtml/esm/handlers.js
var diff = (comment, oldNodes, newNodes) => esm_default3(comment.parentNode, oldNodes, newNodes, diffable, comment);
var handleAnything = (comment) => {
  let oldValue, text2, nodes = [];
  const anyContent = (newValue) => {
    switch (typeof newValue) {
      case "string":
      case "number":
      case "boolean":
        if (oldValue !== newValue) {
          oldValue = newValue;
          if (text2)
            text2.textContent = newValue;
          else
            text2 = document.createTextNode(newValue);
          nodes = diff(comment, nodes, [text2]);
        }
        break;
      case "object":
      case "undefined":
        if (newValue == null) {
          if (oldValue != newValue) {
            oldValue = newValue;
            nodes = diff(comment, nodes, []);
          }
          break;
        }
        if (isArray(newValue)) {
          oldValue = newValue;
          if (newValue.length === 0)
            nodes = diff(comment, nodes, []);
          else if (typeof newValue[0] === "object")
            nodes = diff(comment, nodes, newValue);
          else
            anyContent(String(newValue));
          break;
        }
        if ("ELEMENT_NODE" in newValue && oldValue !== newValue) {
          oldValue = newValue;
          nodes = diff(comment, nodes, newValue.nodeType === 11 ? slice.call(newValue.childNodes) : [newValue]);
        }
    }
  };
  return anyContent;
};
var handleAttribute = (node2, name2) => {
  switch (name2[0]) {
    case "?":
      return boolean(node2, name2.slice(1), false);
    case ".":
      return setter(node2, name2.slice(1));
    case "o":
      if (name2[1] === "n")
        return event(node2, name2);
  }
  switch (name2) {
    case "ref":
      return ref2(node2);
    case "aria":
      return aria(node2);
  }
  return attribute(node2, name2);
};
function handlers(options) {
  const {type, path} = options;
  const node2 = path.reduceRight(reducePath, this);
  return type === "node" ? handleAnything(node2) : type === "attr" ? handleAttribute(node2, options.name) : text(node2);
}

// node_modules/uhtml/esm/rabbit.js
var prefix = "is\xB5";
var cache = esm_default(new WeakMap());
var textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;
var createCache = () => ({
  stack: [],
  entry: null,
  wire: null
});
var createEntry = (type, template) => {
  const {content, updates} = mapUpdates(type, template);
  return {type, template, content, updates, wire: null};
};
var mapTemplate = (type, template) => {
  const text2 = esm_default2(template, prefix, type === "svg");
  const content = createFragment(text2, type);
  const tw = createWalker(content);
  const nodes = [];
  const length = template.length - 1;
  let i2 = 0;
  let search = `${prefix}${i2}`;
  while (i2 < length) {
    const node2 = tw.nextNode();
    if (!node2)
      throw `bad template: ${text2}`;
    if (node2.nodeType === 8) {
      if (node2.textContent === search) {
        nodes.push({type: "node", path: createPath(node2)});
        search = `${prefix}${++i2}`;
      }
    } else {
      while (node2.hasAttribute(search)) {
        nodes.push({
          type: "attr",
          path: createPath(node2),
          name: node2.getAttribute(search)
        });
        node2.removeAttribute(search);
        search = `${prefix}${++i2}`;
      }
      if (textOnly.test(node2.tagName) && node2.textContent.trim() === `<!--${search}-->`) {
        node2.textContent = "";
        nodes.push({type: "text", path: createPath(node2)});
        search = `${prefix}${++i2}`;
      }
    }
  }
  return {content, nodes};
};
var mapUpdates = (type, template) => {
  const {content, nodes} = cache.get(template) || cache.set(template, mapTemplate(type, template));
  const fragment = importNode.call(document, content, true);
  const updates = nodes.map(handlers, fragment);
  return {content: fragment, updates};
};
var unroll = (info, {type, template, values}) => {
  const {length} = values;
  unrollValues(info, values, length);
  let {entry} = info;
  if (!entry || (entry.template !== template || entry.type !== type))
    info.entry = entry = createEntry(type, template);
  const {content, updates, wire} = entry;
  for (let i2 = 0; i2 < length; i2++)
    updates[i2](values[i2]);
  return wire || (entry.wire = persistent(content));
};
var unrollValues = ({stack}, values, length) => {
  for (let i2 = 0; i2 < length; i2++) {
    const hole = values[i2];
    if (hole instanceof Hole)
      values[i2] = unroll(stack[i2] || (stack[i2] = createCache()), hole);
    else if (isArray(hole))
      unrollValues(stack[i2] || (stack[i2] = createCache()), hole, hole.length);
    else
      stack[i2] = null;
  }
  if (length < stack.length)
    stack.splice(length);
};
function Hole(type, template, values) {
  this.type = type;
  this.template = template;
  this.values = values;
}

// node_modules/uhtml/esm/index.js
var {create, defineProperties} = Object;
var tag = (type) => {
  const keyed = esm_default(new WeakMap());
  const fixed = (cache3) => (template, ...values) => unroll(cache3, {type, template, values});
  return defineProperties((template, ...values) => new Hole(type, template, values), {
    for: {
      value(ref3, id) {
        const memo = keyed.get(ref3) || keyed.set(ref3, create(null));
        return memo[id] || (memo[id] = fixed(createCache()));
      }
    },
    node: {
      value: (template, ...values) => unroll(createCache(), {type, template, values}).valueOf()
    }
  });
};
var cache2 = esm_default(new WeakMap());
var render = (where, what) => {
  const hole = typeof what === "function" ? what() : what;
  const info = cache2.get(where) || cache2.set(where, createCache());
  const wire = hole instanceof Hole ? unroll(info, hole) : hole;
  if (wire !== info.wire) {
    info.wire = wire;
    where.textContent = "";
    where.appendChild(wire.valueOf());
  }
  return where;
};
var html = tag("html");
var svg = tag("svg");

// lib/utils.js
var jEQ = (obj1, obj2) => JSON.stringify(obj1) == JSON.stringify(obj2);
var autoResize = (e) => {
  e.target.value = e.target.value.replace(/\n/g, "");
  e.target.style.overflow = "hidden";
  e.target.style.height = "auto";
  e.target.style.height = `${e.target.scrollHeight}px`;
};

// lib/sch/meta.js
var save = (sch, metaForm) => {
  sch.errors = {};
  sch.changes = {};
  validateString(sch, "title", metaForm);
  validateString(sch, "description", metaForm);
  validateEnum(sch, "rw", ["rw", "r", "w"], metaForm);
  validateBoolean(sch, "required", metaForm);
  validate2(sch, metaForm);
  for (let key of Object.keys(sch.changes))
    if ((sch.errors[key] || []).length == 0)
      sch[key] = sch.changes[key];
  return sch;
};
var validate2 = (sch, metaForm) => {
  if (sch.type == RECORD)
    validateTypeRecord(sch, metaForm);
  else if (sch.type == LIST)
    validateTypeList(sch, metaForm);
  else if (sch.type == TUPLE)
    validateTypeTuple(sch, metaForm);
  else if (sch.type == UNION)
    validateTypeUnion(sch, metaForm);
  else if (sch.type == STRING)
    validateTypeString(sch, metaForm);
  else if (sch.type == NUMBER)
    validateTypeNumber(sch, metaForm);
  else if (sch.type == BOOLEAN)
    validateTypeBoolean(sch, metaForm);
  else if (sch.type == NULL)
    validateTypeNull(sch, metaForm);
};
var validateTypeString = (sch, metaForm) => {
  validateRegex(sch, "pattern", metaForm);
  validateInteger(sch, "min", metaForm, {min: 0});
  validateInteger(sch, "max", metaForm, {min: 0});
  validateMinMax(sch, metaForm);
  validateString(sch, "default", metaForm, Object.assign(getValidator(sch, ["min", "max", "pattern"]), {ignoreEmpty: true}));
};
var validateTypeBoolean = (sch, metaForm) => {
  validateBoolean(sch, "default", metaForm);
};
var validateTypeNumber = (sch, metaForm) => {
  validateNumber(sch, "min", metaForm);
  validateNumber(sch, "max", metaForm);
  validateInteger(sch, "multipleOf", metaForm);
  validateMinMax(sch, metaForm);
  validateNumber(sch, "default", metaForm, getValidator(sch, ["min", "max", "multipleOf"]));
};
var validateTypeNull = (sch, metaForm) => {
  validateNull(sch, "default", metaForm);
};
var validateTypeRecord = (sch, metaForm) => {
  validateInteger(sch, "min", metaForm, {min: 0});
  validateInteger(sch, "max", metaForm, {min: 0});
  validateMinMax(sch, metaForm);
};
var validateTypeList = (sch, metaForm) => {
  validateInteger(sch, "min", metaForm, {min: 1});
  validateInteger(sch, "max", metaForm, {min: 1});
  validateMinMax(sch, metaForm);
  validateBoolean(sch, "unique", metaForm);
};
var validateTypeTuple = (sch, metaForm) => {
  validateInteger(sch, "min", metaForm, {min: 1});
  validateInteger(sch, "max", metaForm, {min: 1});
  validateMinMax(sch, metaForm);
};
var validateTypeUnion = (sch, metaForm) => {
};
var getValidator = (sch, keys = []) => {
  let validator = {};
  for (let key of keys) {
    if ((sch.errors[key] || []).length != 0)
      continue;
    if (typeof sch.changes[key] == "number") {
      if (sch.changes[key] || sch.changes[key] == 0)
        validator[key] = sch.changes[key];
    } else
      validator[key] = sch.changes[key];
  }
  return validator;
};
var validateString = (sch, key, params, opts = {}) => {
  if (!params.hasOwnProperty(key))
    return;
  if (opts.ignoreEmpty && params[key] == "")
    return;
  let str = params[key];
  let strLimit = 2 ** 18;
  const byteSize = (s) => new Blob([s]).size;
  if (byteSize(str) > strLimit)
    addError(sch, key, `string size limit is ${Math.ceil(strLimit / 1024)} KB`);
  else if (opts.max && str.length > opts.max)
    addError(sch, key, `must be less than or equal ${opts.max} length`);
  else if (opts.min && str.length < opts.min)
    addError(sch, key, `must be grater than or equal ${opts.min} length`);
  else if (opts.pattern) {
    let regex = new RegExp(opts.pattern);
    if (!regex.test(str))
      addError(sch, key, `must matche pattern ${opts.pattern}`);
  } else
    sch.changes[key] = str;
};
var validateBoolean = (sch, key, params) => {
  if (!params.hasOwnProperty(key))
    return sch.changes[key] = false;
  let bool2 = parseBool(params[key]);
  if (bool2 == void 0)
    addError(sch, key, "must be boolean");
  else
    sch.changes[key] = bool2;
};
var validateNumber = (sch, key, params, opts = {}) => {
  if (!params.hasOwnProperty(key))
    return;
  let num = parseNumber(params[key]);
  if (!num && num != 0)
    addError(sch, key, "must be number");
  else if (opts.min && num < opts.min)
    addError(sch, key, `must be greater than or equal ${opts.min}`);
  else if (opts.max && num > opts.max)
    addError(sch, key, `must be less than than or equal ${opts.max}`);
  else if (opts.multipleOf && num % opts.multipleOf != 0)
    addError(sch, key, `must be multiple of ${opts.multipleOf}`);
  else
    sch.changes[key] = num;
};
var validateInteger = (sch, key, params, opts) => {
  if (!params.hasOwnProperty(key))
    return;
  validateNumber(sch, key, params, opts);
  let int = sch.changes[key];
  if ((sch.errors[key] || []).length == 0 && !Number.isInteger(sch.changes[key]))
    addError(sch, key, "must be integer number");
  else if (int > Number.MAX_SAFE_INTEGER)
    addError(sch, key, `must be less than or equal ${Number.MAX_SAFE_INTEGER}`);
  else if (int < Number.MIN_SAFE_INTEGER)
    addError(sch, key, `must be greater than or equal ${Number.MIN_SAFE_INTEGER}`);
};
var validateRegex = (sch, key, params) => {
  if (!params.hasOwnProperty(key))
    return;
  validateString(sch, key, params);
  if ((sch.errors[key] || []).length == 0) {
    try {
      let regex = params[key];
      if (regex == "")
        return;
      sch.changes[key] = new RegExp(regex);
    } catch (e) {
      addError(sch, key, "invalid regex");
    }
  }
};
var validateMinMax = (sch, params) => {
  if (params.min && params.max) {
    let min = parseNumber(params.min);
    let max = parseNumber(params.max);
    if ((min || min == 0) && (max || max == 0) && min > max) {
      addError(sch, "min", "min is greater than max");
      addError(sch, "max", "max is less than min");
    }
  }
};
var validateNull = (sch, key, params) => {
  if (!params.hasOwnProperty(key))
    return;
  if (params[key] != null)
    addError(sch, key, "must be null");
  else
    sch.changes[key] = params[key];
};
var validateEnum = (sch, key, enum_, params) => {
  if (!params.hasOwnProperty(key))
    return;
  if (!enum_.includes(params[key]))
    addError(sch, key, "value must be r, w, or rw");
  else
    sch.changes[key] = params[key];
};
var addError = (sch, key, msg) => {
  sch.errors[key] = [];
  sch.errors[key].push(msg);
};
var parseNumber = (val) => parseVal(val, "number");
var parseBool = (val) => parseVal(val, "boolean");
var parseVal = (v, type) => {
  try {
    v = JSON.parse(v);
    if (type == typeof v)
      return v;
    else
      return void 0;
  } catch (e) {
    return void 0;
  }
};

// lib/sch/view/meta.js
customElements.define("sch-meta", class extends HTMLElement {
  connectedCallback() {
    this.addEventListener("change", this.handleMetaChange);
    this.addEventListener("input", this.handleMetaChange);
    this.addEventListener("paste", this.handleMetaChange);
    this.addEventListener("focusout", this.handleMetaChange);
  }
  disconnectedCallback() {
    this.removeEventListener("change", this.handleMetaChange);
    this.removeEventListener("input", this.handleMetaChange);
    this.removeEventListener("paste", this.handleMetaChange);
    this.removeEventListener("focusout", this.handleMetaChange);
  }
  handleMetaChange(e) {
    if (e.target instanceof HTMLTextAreaElement || e.target instanceof HTMLInputElement || e.target instanceof HTMLSelectElement) {
      const value2 = (input) => {
        if (["checkbox", "radio"].includes(input.type))
          return input.checked;
        else
          return input.value;
      };
      let inputs = this.querySelector("form").elements;
      let post = {};
      for (let i2 = 0; i2 < inputs.length; i2++) {
        let val = value2(inputs[i2]);
        if (!(inputs[i2] instanceof HTMLTextAreaElement) && val == "")
          continue;
        post[inputs[i2].name] = val;
      }
      let detail = {
        path: e.target.closest("[data-path]").dataset.path,
        file: e.target.closest("[data-file]").dataset.file,
        attrs: post
      };
      this.dispatchEvent(new CustomEvent("sch-update", {detail, bubbles: true}));
    }
  }
});
var renderMeta = (container, sch, root) => {
  try {
    render(container, html.for(sch)`
    <p>${sch.key || "-"}</p>
    <form data-path="${sch.path}" data-file="${sch.rootKey}">
      ${textInput(sch, "title", {keyDisplay: "Title"})}
      ${textInput(sch, "description", {keyDisplay: "Description"})}
      ${renderTypeMeta(sch)}
      ${enumInput(sch, "rw", {collection: [["r", "Readonly"], ["w", "Writeonly"], ["rw", "Read and Write"]], selected: "rw", keyDisplay: "Read / Write"})}
      ${valueInput(sch, "default", {keyDisplay: "Default"})}
    </form>
  `);
  } catch (e) {
  }
};
var labelA = (sch, key, children, opts = {}) => {
  var _a;
  return html`
  <label class="${opts.readonly && `meta-box ${key} readonly` || `meta-box ${key}`}">
    <p class="l">${opts.keyDisplay || key} ${opts.readonly && html`<span>· readonly</span>`}</p>
    ${children}
    ${(_a = errors(sch, key)) == null ? void 0 : _a.map((err) => html`<p class="err">${err}</p>`)}
  </label>
  `;
};
var textInput = (sch, key, opts = {}) => labelA(sch, key, html`
    <textarea name="${name(sch, key)}" maxlength="${opts.maxlength}" minlength="${opts.minlength}" ?readonly="${opts.readonly}" rows="1" spellcheck="false" class="${errors(sch, key) && "invalid"}" oninput="${autoResize}">${sch[key] || opts.value}</textarea>
  `, opts);
var numberInput = (sch, key, opts = {}) => labelA(sch, key, html`
    <input type="number" name="${name(sch, key)}" inputmode="decimal" step="any" min="${opts.min}" max="${opts.max}" value="${sch[key] || opts.value}" ?readonly="${opts.readonly}" class="${errors(sch, key) && "invalid"}">
  `, opts);
var integerInput = (sch, key, opts = {}) => labelA(sch, key, html`
    <input type="number" name="${name(sch, key)}" inputmode="numeric" pattern="[0-9]*" min="${opts.min}" max="${opts.max}" value="${sch[key] || opts.value}" ?readonly="${opts.readonly}" class="${errors(sch, key) && "invalid"}">
  `, opts);
var boolInput = (sch, key, opts = {}) => labelA(sch, key, html`
    <input type="checkbox" name="${name(sch, key)}" ?disabled="${opts.readonly}" ?checked="${sch[key] || opts.value}">
  `, opts);
var enumInput = (sch, key, opts = {}) => labelA(sch, key, html`
    <select name="${name(sch, key)}" ?disabled="${opts.readonly}">
      ${opts.collection.map(([v, t]) => html`<option value="${v}" ?selected="${(sch[key] || opts.selected) == v}">${t}</option>`)}
    </select>
  `, opts);
var valueInput = (sch, key, opts = {}) => {
  switch (sch.type) {
    case BOOLEAN:
      return boolInput(sch, key, opts);
      break;
    case NUMBER:
      return numberInput(sch, key, opts);
      break;
    case STRING:
      return textInput(sch, key, opts);
      break;
    default:
      return ``;
  }
};
var name = (sch, key) => key;
var renderTypeMeta = (sch) => {
  let htmls;
  switch (true) {
    case sch.type == RECORD:
      htmls = [
        integerInput(sch, "min", {keyDisplay: "Min Properties", value: Object.keys(sch.fields).length, readonly: true}),
        integerInput(sch, "max", {keyDisplay: "Max Properties", value: Object.keys(sch.fields).length, readonly: true})
      ];
      break;
    case sch.type == LIST:
      htmls = [
        integerInput(sch, "min", {keyDisplay: "Min Items", min: 1, value: 1}),
        integerInput(sch, "max", {keyDisplay: "Max Items", min: 1}),
        boolInput(sch, "unique", {keyDisplay: "Item uniqueness"})
      ];
      break;
    case sch.type == TUPLE:
      htmls = [
        integerInput(sch, "min", {keyDisplay: "Min Items", value: sch.schs.length, readonly: true}),
        integerInput(sch, "max", {keyDisplay: "Max Items", value: sch.max || sch.schs.length})
      ];
      break;
    case sch.type == STRING:
      htmls = [
        integerInput(sch, "min", {keyDisplay: "Min Length", min: 0}),
        integerInput(sch, "max", {keyDisplay: "Max Length", min: 0}),
        textInput(sch, "pattern", {keyDisplay: "Pattern", maxlength: 256})
      ];
      break;
    case sch.type == NUMBER:
      htmls = [
        numberInput(sch, "min", {keyDisplay: "Min"}),
        numberInput(sch, "max", {keyDisplay: "Max"}),
        numberInput(sch, "multipleOf", {keyDisplay: "Multiple of", min: 1})
      ];
      break;
    case sch.type == INTEGER:
      htmls = [];
    case sch.type == BOOLEAN:
      htmls = [];
    case sch.type == NULL:
      htmls = [];
    case sch.type == UNION:
      htmls = [];
    case sch.type == ANY:
      htmls = [];
    case sch.type == REF:
      htmls = [];
    case sch.type == VALUE:
      htmls = [];
    default:
      htmls = [];
  }
  if (sch._meta.parent.type == RECORD && sch._meta.parent._box != "file")
    htmls.push(boolInput(sch, "required", {keyDisplay: "Required"}));
  return htmls;
};
var errors = (sch, key) => sch.errors && sch.errors[key];

// lib/sch/view.js
var renderRoot = (el, root, opts = {}) => {
  try {
    let models = root._models || root.order.reduce((acc, m) => {
      acc[root.fields[m].$anchor] = m;
      return acc;
    }, {});
    let ui = {level: 1, tab: 0, models, rootBox: root._box, rootKey: root.key};
    viewMain(el, {
      sch: root,
      ui: Object.assign(ui, opts.ui),
      path: root.path || "",
      key: root.key,
      parent: {type: root.type, _box: root._box}
    });
  } catch (e) {
    console.log(e);
  }
};
var viewMain = (el, assigns) => render(document.querySelector(el), html`
  <theme>
    <ul role="tree" aria-multiselectable="true" class="text-sm" tabindex="-1">
      ${viewModel(assigns)}
    </ul>
  </theme>
  ${null}
`);
var viewModel = (assigns) => {
  switch (true) {
    case assigns.sch._box == assigns.ui.rootBox:
      return viewRootItem(assigns);
    case CONTAINER_TYPES.includes(assigns.sch.type):
      return viewFolder(assigns);
    default:
      return viewFile(assigns);
  }
};
var viewRootItem = (assigns) => html.for(assigns.sch, assigns.ui.rootKey + assigns.path)`
  <li id="${assigns.path}" .dataset="${{tag: assigns.sch._box}}" .key="${assigns.key}" .index="${0}" aria-posinset="${1}" class="root-item" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
    <dfn class="h">
      ${wordBreakHtml(assigns.key)}
    </dfn>
    <ul data-group="${keyedOrIndexed(assigns.sch)}" role="group">
      ${viewItself(assigns)}
    </ul>
  </li>`;
var viewFolder = (assigns) => html.for(assigns.sch, assigns.ui.rootKey + assigns.path)`
  <li id="${assigns.path}" .dataset="${{tag: assigns.sch._box}}" .key="${assigns.key}" .index="${assigns.ui.index}" aria-posinset="${assigns.ui.index + 1}" class="folder" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
    <dfn class="h">
      ${viewKey(Object.assign(assigns, {key: wordBreakHtml(assigns.key)}))}
      ${viewType(assigns)}
      ${viewMeta(assigns)}
    </dfn>
    <ul data-group="${keyedOrIndexed(assigns.sch)}" role="group">
      ${viewItself(assigns)}
    </ul>
  </li>`;
var viewFile = (assigns) => html.for(assigns.sch, assigns.ui.rootKey + assigns.path)`
  <li id="${assigns.path}" .dataset="${{tag: assigns.sch._box}}" .key="${assigns.key}" .index="${assigns.ui.index}" aria-posinset="${assigns.ui.index + 1}" class="file" role="treeitem" aria-level="${assigns.ui.level}" aria-selected="false" tabindex="-1">
    ${viewKey(Object.assign(assigns, {key: wordBreakHtml(assigns.key)}))}
    ${viewType(assigns)}
    ${viewMeta(assigns)}
  </li>`;
var viewItself = (assigns) => {
  if (assigns.ui.depthLimit && assigns.ui.level >= assigns.ui.depthLimit)
    return html``;
  switch (true) {
    case [RECORD].includes(assigns.sch.type):
      return viewKeyed(assigns);
    case [TUPLE].includes(assigns.sch.type):
      return viewIndexed(assigns);
    case [LIST].includes(assigns.sch.type):
      return viewSingled(assigns);
    case [UNION].includes(assigns.sch.type):
      return viewNonKeyed(assigns);
    default:
      return html``;
  }
};
var viewKeyed = (assigns) => assigns.sch.order.map((k, i2) => viewModel({
  key: k,
  sch: assigns.sch.fields[k],
  parent: {type: assigns.sch.type, path: assigns.path, _box: assigns.sch._box},
  ui: {...assigns.ui, level: assigns.ui.level + 1, index: i2},
  path: `${assigns.path}[${k}]`
}));
var viewIndexed = (assigns) => assigns.sch.schs.map((sch, i2) => viewModel({
  key: i2,
  sch: assigns.sch.schs[i2],
  parent: {type: assigns.sch.type, path: assigns.path, _box: assigns.sch._box},
  ui: {...assigns.ui, level: assigns.ui.level + 1, index: i2},
  path: `${assigns.path}[][${i2}]`
}));
var viewSingled = (assigns) => viewModel({
  key: 0,
  sch: assigns.sch.sch,
  parent: {type: assigns.sch.type, path: assigns.path, _box: assigns.sch._box},
  ui: {...assigns.ui, level: assigns.ui.level + 1, index: 0},
  path: `${assigns.path}[][${0}]`
});
var viewNonKeyed = (assigns) => assigns.sch.schs.map((sch, i2) => viewModel({
  key: "",
  sch: assigns.sch.schs[i2],
  parent: {type: assigns.sch.type, path: assigns.path, _box: assigns.sch._box},
  ui: {...assigns.ui, level: assigns.ui.level + 1, index: i2},
  path: `${assigns.path}[][${i2}]`
}));
var indent = (assigns) => `padding-left: ${(assigns.ui.level - 1) * 1.25 + assigns.ui.tab}rem`;
var textInput2 = (id, parentPath, content) => html`<textarea id="${id}" class="no-resize" spellcheck="false" maxlength="256" rows="1" autofocus
  data-parent-path="${parentPath}"
  oninput="${autoResize}"
  >${content}</textarea>`;
var viewKey = (assigns) => assigns.parent._box == assigns.ui.rootBox ? viewKeyRoot(assigns) : viewKeyNonRoot(assigns);
var viewKeyRoot = (assigns) => html`
  <span class="def" style="${indent(assigns)}">
    ${modelTypeText(assigns.sch, assigns.ui)}
  </span>
  <span class="k">${editableKey(assigns)}</span>
  <span class="s">=</span>
  `;
var viewKeyNonRoot = (assigns) => {
  switch (true) {
    case assigns.parent.type == UNION:
      return html`
      <span class="" style="${indent(assigns)}"></span>
      <span class="s">|</span>
      `;
    case assigns.parent.type == LIST:
      return html`
      <span class="k" style="${indent(assigns)}"></span>
      <span class="s">└</span>
      `;
    default:
      return html`
      <span class="k" style="${indent(assigns)}">
        ${editableKey(assigns)}
      </span >
      <span class="s">:</span>
    `;
  }
};
var editableKey = (assigns) => assigns.sch.uiMode == "editKey" ? textInput2("key-edit", assigns.parent.path, assigns.key) : html`${assigns.key}`;
var viewType = (assigns) => assigns.parent._box == assigns.ui.rootBox ? viewTypeRoot(assigns) : viewTypeNonRoot(assigns);
var viewTypeRoot = (assigns) => {
  if (assigns.ui.viewTypeRoot)
    return assigns.ui.viewTypeRoot(assigns);
  else
    return html`<span class="t">${editableType(assigns)}</span>`;
};
var viewTypeNonRoot = (assigns) => html`<span class="t">${editableType(assigns)}</span>`;
var editableType = (assigns) => assigns.sch.uiMode == "editType" ? textInput2("type-edit", assigns.parent.path, typeTextPopulated(assigns.sch, assigns.ui)) : html`${typeText(assigns.sch, assigns.ui)}`;
var typeTextPopulated = (sch, ui) => {
  switch (true) {
    case sch.type == VALUE:
      return JSON.stringify(sch.const);
    case sch.type == REF:
      return ui.models[sch.$ref];
    default:
      return sch.type;
  }
};
var typeText = (sch, ui) => {
  let text2;
  switch (true) {
    case (sch.type == RECORD && jEQ(sch.fields, {})):
      text2 = "{ any }";
      break;
    case sch.type == RECORD:
      text2 = `{ \xA0 }`;
      break;
    case sch.type == LIST:
      text2 = html`[ ${typeText(sch.sch, ui)} ]`;
      break;
    case sch.type == TUPLE:
      text2 = "( \xA0 )";
      break;
    case sch.type == STRING:
      text2 = "string";
      break;
    case sch.type == NUMBER:
      text2 = "number";
      break;
    case sch.type == INTEGER:
      text2 = "integer";
      break;
    case sch.type == BOOLEAN:
      text2 = "bool";
      break;
    case sch.type == NULL:
      text2 = "null";
      break;
    case sch.type == UNION:
      text2 = "||";
      break;
    case sch.type == ANY:
      text2 = "any";
      break;
    case (sch.type == REF && !!ui.models[sch.$ref]):
      text2 = html`<span class="ref">${sch._text = ui.models[sch.$ref]}</span>`;
      break;
    case sch.type == REF:
      text2 = html`<span class="ref notfound" title="Ref type">${`${sch._text} (#404)`}</span>`;
      break;
    case sch.type == VALUE:
      text2 = html`<span class="value" title="Value type">${JSON.stringify(sch.const)}</span>`;
      break;
    default:
      text2 = "please define what type ${sch} is";
  }
  if (ui.typeText)
    text2 = ui.typeText(sch, ui) || text2;
  return text2;
};
var wordBreakHtml = (word) => word;
var keyedOrIndexed = (sch) => {
  switch (true) {
    case [RECORD].includes(sch.type):
      return "keyed";
    case [TUPLE, UNION].includes(sch.type):
      return "indexed";
    default:
      return "none";
  }
};
var modelTypeText = (sch, ui) => {
  let text2;
  switch (true) {
    case sch.type == RECORD:
      text2 = "record";
      break;
    case sch.type == LIST:
      text2 = "list";
      break;
    case sch.type == TUPLE:
      text2 = "tuple";
      break;
    case sch.type == UNION:
      text2 = "union";
      break;
    default:
      text2 = "field";
  }
  if (ui.modelTypeText)
    text2 = ui.modelTypeText(sch, ui) || text2;
  return text2;
};
var viewMeta = (assigns) => {
  let htmls;
  switch (true) {
    case (assigns.parent.type == RECORD && assigns.sch.required):
      htmls = [html`<span class="m"> · required</span>`];
      break;
    default:
      htmls = [];
  }
  return htmls;
};

// lib/aria_tree.js
var aria_tree_exports = {};
__export(aria_tree_exports, {
  clearClipboard: () => clearClipboard,
  createWalker: () => createWalker2,
  findUnselectedNode: () => findUnselectedNode,
  reselectNodes: () => reselectNodes,
  selectMultiNode: () => selectMultiNode,
  selectMultiNodeTo: () => selectMultiNodeTo,
  selectNode: () => selectNode,
  selectedGroupedByParent: () => selectedGroupedByParent,
  toggleSelectNode: () => toggleSelectNode
});
var ARIA_SELECTED = "aria-selected";
var createWalker2 = (tree) => {
  tree._walker = tree.ownerDocument.createTreeWalker(tree, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node2) => {
      if (node2.hasAttribute(ARIA_SELECTED))
        return NodeFilter.FILTER_ACCEPT;
      else
        return NodeFilter.FILTER_SKIP;
    }
  }, false);
  return tree;
};
var selectNode = (tree, node2, opts = {focus: true}) => {
  if (node2 && !node2.isConnected)
    node2 = tree.querySelector(`[id='${CSS.escape(node2.id)}']`);
  if (!node2)
    return;
  tree._walker.currentNode = node2;
  deselectAllNode(tree);
  setSelect(node2);
  opts.focus && node2.focus();
};
var toggleSelectNode = (current, node2) => {
  if (current)
    current.tabIndex = -1;
  setToggle(node2);
};
var selectMultiNode = (current, nextStepSibling, opts = {focus: true}) => {
  if (!nextStepSibling)
    return;
  if (current)
    current.tabIndex = -1;
  if (nextStepSibling.getAttribute(ARIA_SELECTED) == "true")
    setToggle(current);
  else
    setSelect(nextStepSibling);
  opts.focus && nextStepSibling.focus();
};
var deselectAllNode = (tree) => {
  for (let item of tree.querySelectorAll(`[${ARIA_SELECTED}='true']`))
    setDeselect(item);
  for (let a of tree.querySelectorAll(".item-pasted"))
    a.classList.remove("item-pasted", "up", "down");
};
var selectStepNodeTo = (tree, stepSiblingFn, target, opts = {}) => {
  var _a, _b, _c;
  let current = tree._walker.currentNode;
  let nextSibling = stepSiblingFn();
  if (!nextSibling)
    return;
  if (current == target)
    return (_a = opts.target) == null ? void 0 : _a.call(null, target);
  else {
    (_b = opts.pre) == null ? void 0 : _b.call(null, current, nextSibling);
    selectStepNodeTo(tree, stepSiblingFn, target, opts);
    (_c = opts.post) == null ? void 0 : _c.call(null, current, nextSibling);
  }
};
var selectMultiNodeTo = (tree, start, target) => {
  if (!start || !target)
    return;
  switch (start.compareDocumentPosition(target)) {
    case Node.DOCUMENT_POSITION_FOLLOWING:
      tree._walker.currentNode = start;
      selectStepNodeTo(tree, () => tree._walker.nextSibling(), target, {
        pre: (current, nextSibling) => {
          selectMultiNode(current, nextSibling, {focus: false});
        }
      });
      tree._walker.currentNode = target;
      setSelect(target);
      target.focus();
      break;
    case Node.DOCUMENT_POSITION_PRECEDING:
      tree._walker.currentNode = start;
      setSelect(target.parentNode.closest(`[${ARIA_SELECTED}]`));
      selectStepNodeTo(tree, () => tree._walker.previousSibling(), target, {
        pre: (current, nextSibling) => {
          selectMultiNode(current, nextSibling, {focus: false});
        }
      });
      setDeselect(target.parentNode.closest(`[${ARIA_SELECTED}]`));
      tree._walker.currentNode = target;
      setSelect(target);
      target.focus();
      break;
  }
};
var setSelect = (node2) => {
  if (!node2)
    return;
  node2.setAttribute(ARIA_SELECTED, true);
  node2.tabIndex = 0;
};
var setDeselect = (node2) => {
  if (!node2)
    return;
  node2.setAttribute(ARIA_SELECTED, false);
  node2.tabIndex = -1;
};
var setToggle = (node2) => (node2 == null ? void 0 : node2.getAttribute(ARIA_SELECTED)) == "true" ? setDeselect(node2) : setSelect(node2);
var findUnselectedNode = (fstep, nextNode) => {
  do
    nextNode = fstep();
  while ((nextNode == null ? void 0 : nextNode.getAttribute(ARIA_SELECTED)) == "true");
  return nextNode;
};
var filterMostOuters2 = (paths) => {
  return paths.filter((p) => {
    for (let p_ of paths) {
      if (p == p_)
        return true;
      else if (p.startsWith(p_))
        return false;
    }
  });
};
var reselectNodes = (tree, childIncidesPerParent, opts = {}) => {
  deselectAllNode(tree);
  for (let parent of filterMostOuters2(Object.keys(childIncidesPerParent))) {
    let indices = childIncidesPerParent[parent];
    if (parent == "")
      parent = tree.querySelector(`[id][aria-level]`);
    else
      parent = tree.querySelector(`[id='${CSS.escape(parent)}'][aria-level]`);
    if (!parent)
      continue;
    let dstLevel = parseInt(parent.getAttribute("aria-level"));
    let children = parent.querySelectorAll(`[aria-level='${dstLevel + 1}'][role='treeitem']`);
    for (let i2 = 0; i2 < indices.length; i2++) {
      let index = indices[i2].index;
      let a = children[index];
      if (!a)
        return;
      a.classList.add("item-pasted");
      if (opts.direction)
        a.classList.add(opts.direction);
      selectMultiNode(null, a, {focus: i2 == indices.length - 1});
      tree._walker.currentNode = a;
    }
  }
};
var selectedGroupedByParent = (tree, opts = {}) => {
  let selected = tree.querySelectorAll(`${opts.ops || `[${ARIA_SELECTED}='true']`}`);
  let acc = {};
  for (let i2 = 0; i2 < selected.length; i2++) {
    let child = selected[i2];
    let parent = child.parentNode.closest("[role='treeitem']");
    if (!parent)
      break;
    child.index = child.index || parseInt(child.getAttribute("aria-posinset")) - 1;
    acc[parent.id] = acc[parent.id] || [];
    acc[parent.id].push(child);
  }
  return acc;
};
var clearClipboard = (tree) => {
  tree.querySelectorAll(".item-cutting, .item-copying").forEach((a) => a.classList.remove("item-cutting", "item-copying"));
  window._treeClipboard = null;
};

// lib/project.js
var project_exports = {};
__export(project_exports, {
  anchorsModels: () => anchorsModels,
  createProjectStore: () => createProjectStore,
  getFileStore: () => getFileStore,
  handleProjectContext: () => handleProjectContext,
  projectToStore: () => projectToStore
});
var FILE_TAG = "file";
var PROJECT_TAG = "project";
var createProjectStore = () => createStore({
  tag: PROJECT_TAG,
  allowedSchs: [() => createStore({tag: FILE_TAG, paste: {deny: [FILE_TAG]}})],
  put: {pos: "append"}
});
var getFileStore = (projectStore, filename) => get(projectStore, `[${filename}]`);
var handleProjectContext = (projectStore, target, filename, command) => {
  if (target.closest("[id='project']") && filename != "")
    switch (true) {
      case isContextSwitchedCmd(command.name):
        changeFile(projectStore, filename);
        break;
      case ["addSch", "submitEdit"].includes(command.name):
        let fileStore = get(projectStore, `[${filename}]`);
        let fmodelTree = document.querySelector("[id='fmodel'] [role='tree']");
        fmodelTree._render(fileStore);
    }
  else if (target.closest("[id='fmodel']"))
    switch (true) {
      case isModelChangedCmd(command.name):
        let fileStore = get(projectStore, `[${filename}]`);
        fileStore._models = anchorsModels(projectStore, fileStore);
        let fmodelTree = document.querySelector("[id='fmodel'] [role='tree']");
        fmodelTree._render(fileStore);
    }
};
var anchorsModels = (projectStore, fileStore) => {
  let modelsAcc = {};
  for (let filename of projectStore.order) {
    let file = projectStore.fields[filename];
    for (let modelname of file.order)
      modelsAcc[file.fields[modelname].$anchor] = filename != fileStore.key ? `${filename}.${modelname}` : modelname;
  }
  return modelsAcc;
};
var fileToStore = (file, store) => {
  for (let fmodel of file.fmodels)
    store.fields[fmodel.key] = fmodel.sch;
  store.key = file.key;
  store.order = file.order;
  return putAnchor(() => store);
};
var projectToStore = (project, store) => {
  for (let file of project.files)
    store.fields[file.key] = fileToStore(file, createStore({tag: FILE_TAG, paste: {deny: [FILE_TAG]}}));
  store.key = project.key;
  store.order = project.order;
  return putAnchor(() => store);
};
var changeFile = (projectStore, filename) => {
  let fileStore = get(projectStore, `[${filename}]`);
  if ((fileStore == null ? void 0 : fileStore._box) == FILE_TAG) {
    fileStore._models = anchorsModels(projectStore, fileStore);
    initModelView({store: fileStore, target: "[id='fmodel']", metaSelector: "sch-meta"});
    if (!window._treeClipboard) {
      let fmodelTree = document.querySelector("[id='fmodel'] [role='tree']");
      fmodelTree._aria.clearClipboard(fmodelTree);
    }
  }
};

// lib/main.js
var allSchs = [string, record, list, tuple, union, any, bool, number, nil, () => value('"json string"')];
var createStore = (opts = {}) => {
  let s = putAnchor(record);
  s._box = opts.tag || FMODEL_BOX;
  s._allSchs = opts.allowedSchs || allSchs;
  if (opts.put)
    s.put = opts.put;
  if (opts.paste)
    s.paste = opts.paste;
  return s;
};
var isContextSwitchedCmd = (cmdname) => [
  selectUp,
  selectDown,
  selectUpEnd,
  selectDownEnd,
  selectRoot,
  selectLast,
  cloneUp,
  cloneDown,
  deleteSelected,
  {name: "clickSelect"}
].map((cmd) => cmd.name).includes(cmdname);
var isModelChangedCmd = (cmdname) => [
  addSch,
  deleteSelected,
  submitEdit
].map((cmd) => cmd.name).includes(cmdname);
var treeKeyDownCmd = () => new Map([
  ["shift-meta-ArrowUp", selectMultiNodeUpTo],
  ["shift-meta-ArrowDown", selectMultiNodeDownTo],
  ["shift-ArrowUp", selectMultiNodeUp],
  ["shift-ArrowDown", selectMultiNodeDown],
  ["meta-ArrowUp", selectUpEnd],
  ["meta-ArrowDown", selectDownEnd],
  ["ArrowUp", selectUp],
  ["ArrowDown", selectDown],
  ["Home", selectRoot],
  ["End", selectLast],
  ["shift-+", addSch],
  ["Enter", activateEditKey],
  ["shift-Enter", activateEditType],
  ["Delete", deleteSelected],
  ["meta-x", cut],
  ["meta-c", copy],
  ["meta-v", paste],
  ["shift-alt-ArrowUp", cloneUp],
  ["shift-alt-ArrowDown", cloneDown],
  ["alt-ArrowUp", reorderUp],
  ["alt-ArrowDown", reorderDown],
  ["Escape", ({tree}) => clearClipboard(tree)]
]);
var handleTreeKeydown = (store, opts = {}) => function(e) {
  handleTreeKeydown_(e, this, store, opts);
};
async function handleTreeKeydown_(e, tree, store, opts) {
  if (e.target instanceof HTMLTextAreaElement)
    return handleTextAreaKeyDown(e, tree, store);
  let command = treeKeyDownCmd().get(toCmdkey(e));
  if (!command)
    return;
  if ((opts.denyCmds || []).includes(command.name))
    return;
  command({tree, store});
  switch (e.code) {
    case "ArrowUp":
      e.preventDefault();
      break;
    case "ArrowDown":
      e.preventDefault();
      break;
  }
  tree.renderSchMeta();
  if (!tree._walker.currentNode.isConnected)
    tree._walker.currentNode = tree.querySelector(`[id='${CSS.escape(tree._walker.currentNode.id)}']`);
  let fileItem = tree._walker.currentNode.closest("[data-tag='file']");
  if (fileItem)
    tree.dispatchEvent(new CustomEvent("tree-command", {bubbles: true, detail: {file: fileItem.key, path: tree._walker.currentNode.id, command}}));
}
var textAreaKeyDownCmd = () => new Map([
  ["Enter", submitEdit]
]);
var handleTextAreaKeyDown = (e, tree, store) => {
  let textArea = e.target;
  let command = textAreaKeyDownCmd().get(toCmdkey(e));
  if (!command)
    return;
  command({tree, store}, textArea);
  tree.renderSchMeta();
  let fileItem = tree._walker.currentNode.closest("[data-tag='file']");
  if (fileItem)
    tree.dispatchEvent(new CustomEvent("tree-command", {bubbles: true, detail: {file: fileItem.key, path: tree._walker.currentNode.id, command}}));
};
var handleTreeClick = (store) => function(e) {
  return handleTreeClick_(e, this, store);
};
function handleTreeClick_(e, tree, store) {
  let start = tree._walker.currentNode;
  let target = e.target.closest("[role='treeitem']");
  let notFocusIfTextArea = !tree.querySelector("textarea");
  if (!target)
    return;
  if (e.shiftKey || e.metaKey) {
    switch (start.compareDocumentPosition(target)) {
      case Node.DOCUMENT_POSITION_CONTAINS:
        return selectNode(tree, target);
      case Node.DOCUMENT_POSITION_CONTAINED_BY:
        return selectNode(tree, start);
      default:
        if (target.parentNode.closest("[role='treeitem']") != start.parentNode.closest("[role='treeitem']"))
          return selectNode(tree, target);
    }
  }
  if (e.shiftKey)
    selectMultiNodeTo(tree, start, target);
  else if (e.metaKey)
    toggleSelectNode(start, tree._walker.currentNode = target);
  else {
    let fileItem = target.closest("[data-tag='file']");
    const clickSelect = ({tree: tree2, store: store2}) => selectNode(tree2, target, {focus: notFocusIfTextArea});
    clickSelect({tree, store});
    if (fileItem)
      tree.dispatchEvent(new CustomEvent("tree-command", {bubbles: true, detail: {file: fileItem.key, path: target.id, command: clickSelect}}));
  }
  tree.renderSchMeta();
}
var renderSchMeta = ({tree, store}) => {
  let selected = tree.querySelectorAll("[id='fmodel'] [aria-selected='true']");
  if (selected.length == 1) {
    let sch = get(store, selected[0].id);
    sch.key = selected[0].key;
    sch.path = selected[0].id;
    sch.rootKey = tree.querySelector(".root-item").key;
    renderMeta(tree._metaContainer, sch, store);
  }
};
var toCmdkey = ({shiftKey, metaKey, altKey, ctrlKey, key}) => {
  let cmd = [];
  if (shiftKey)
    cmd.push("shift");
  if (metaKey)
    cmd.push("meta");
  else if (ctrlKey)
    cmd.push("meta");
  if (altKey)
    cmd.push("alt");
  if (key)
    cmd.push(key);
  return cmd.join("-");
};
var selectMultiNodeUpTo = ({tree}) => {
  let current = tree._walker.currentNode;
  let upEnd = tree._walker.parentNode() && tree._walker.firstChild();
  selectMultiNodeTo(tree, current, upEnd);
};
var selectMultiNodeDownTo = ({tree}) => {
  let current = tree._walker.currentNode;
  let downEnd = tree._walker.parentNode() && tree._walker.lastChild();
  selectMultiNodeTo(tree, current, downEnd);
};
var selectMultiNodeUp = ({tree}) => {
  let current = tree._walker.currentNode;
  let upNext = tree._walker.previousSibling();
  selectMultiNode(current, upNext);
};
var selectMultiNodeDown = ({tree}) => {
  let current = tree._walker.currentNode;
  let downNext = tree._walker.nextSibling();
  selectMultiNode(current, downNext);
};
var selectUpEnd = ({tree}) => {
  let upEnd = tree._walker.parentNode() && tree._walker.firstChild();
  selectNode(tree, upEnd);
};
var selectDownEnd = ({tree}) => {
  let upEnd = tree._walker.parentNode() && tree._walker.lastChild();
  selectNode(tree, upEnd);
};
var selectUp = ({tree}) => selectNode(tree, tree._walker.previousNode());
var selectDown = ({tree}) => selectNode(tree, tree._walker.nextNode());
var selectRoot = ({tree}) => {
  while (tree._walker.parentNode()) {
  }
  selectNode(tree, tree._walker.currentNode);
};
var selectLast = ({tree}) => {
  while (tree._walker.nextNode()) {
  }
  selectNode(tree, tree._walker.currentNode);
};
var addSch = ({tree, store}) => {
  var _a;
  let currentNode = tree._walker.currentNode;
  let parent = get(store, currentNode.id);
  let index;
  let allowedSchs = parent._allSchs || store._allSchs;
  if (((_a = parent.put) == null ? void 0 : _a.pos) == "prepend")
    index = 0;
  else
    index = Number.MAX_SAFE_INTEGER;
  put(store, currentNode.id, [{k: null, sch: allowedSchs[0], index}]);
  tree._render();
  tree.scrollTop = tree.style.height;
  selectNode(tree, currentNode);
};
var activateEditKey = ({tree, store}) => {
  var _a, _b;
  let group = (_b = (_a = tree._walker.currentNode.closest("[role='group']")) == null ? void 0 : _a.dataset) == null ? void 0 : _b.group;
  if (group == "keyed")
    activateEdit({tree, store, editMode: "editKey"});
};
var activateEditType = ({tree, store}) => {
  activateEdit({tree, store, editMode: "editType"});
};
var activateEdit = ({tree, store, editMode}) => {
  let currentNode = tree._walker.currentNode;
  update(store, currentNode.id, (a, m) => ({...a, uiMode: editMode}));
  tree._render();
  let textArea = tree.querySelector("textarea");
  if (!textArea)
    return;
  textArea._treeItem = currentNode;
  textArea.onblur = (e) => cancelTextArea(tree, store, textArea);
  textArea.focus();
};
var cancelTextArea = (tree, store, textArea) => {
  let updatedNode = update(store, textArea._treeItem.id, (a, m) => Object.assign(a, {uiMode: "cancelled-edit"}));
  tree._render();
  if (updatedNode) {
    tree._walker.currentNode = tree.querySelector(`[id='${CSS.escape(textArea._treeItem.id)}']`);
    selectNode(tree, tree._walker.currentNode);
  }
};
var submitEdit = ({tree, store}, textArea) => {
  if (textArea.id == "key-edit")
    editSelected(tree, store, textArea, renameSelected);
  else if (textArea.id == "type-edit")
    editSelected(tree, store, textArea, changeTypeSelected);
};
var editSelected = (tree, store, textArea, f) => {
  let currentNode = tree._walker.currentNode;
  textArea._treeItem = textArea.closest("[role='treeitem']");
  selectNode(tree, textArea._treeItem, {focus: false});
  let currentId = f(tree, store, textArea) || currentNode.id;
  update(store, currentId, (a, m) => Object.assign(a, {uiMode: "editted"}));
  tree._render();
  tree._walker.currentNode = tree.querySelector(`[id='${CSS.escape(currentId)}']`);
  selectNode(tree, tree._walker.currentNode);
};
var changeTypeSelected = (tree, store, textArea) => {
  let newSch = store._allSchs.find((sch_) => sch_().type == textArea.value);
  let anchor = Object.keys(store._models).find((anchor2) => store._models[anchor2] == textArea.value);
  let valSch = value(textArea.value);
  if (newSch)
    changeType(store, textArea._treeItem.id, newSch);
  else if (anchor)
    changeType(store, textArea._treeItem.id, () => ref(anchor));
  else if (valSch)
    changeType(store, textArea._treeItem.id, () => valSch);
  return tree._walker.currentNode.id;
};
var renameSelected = (tree, store, textArea) => {
  let indicesPerParent = selectedGroupedByParent(tree);
  let dstPath = textArea.dataset.parentPath;
  indicesPerParent[textArea.dataset.parentPath] = indicesPerParent[textArea.dataset.parentPath].filter((c) => c.id == textArea._treeItem.id).map((c) => ({id: c.id, newK: textArea.value, index: c.index}));
  let renameIndex = indicesPerParent[textArea.dataset.parentPath][0].index;
  let moved = move(store, {dstPath, startIndex: renameIndex}, indicesPerParent);
  let newKey = moved[dstPath][0].k;
  let ancestor = textArea._treeItem.parentNode.closest("[role='treeitem']");
  return `${ancestor.id}[${newKey}]`;
};
var deleteSelected = ({tree, store}) => {
  let nextStepNode = findUnselectedNode(() => tree._walker.nextSibling()) || findUnselectedNode(() => tree._walker.previousSibling()) || findUnselectedNode(() => tree._walker.parentNode());
  deleteSelected_(tree, store);
  tree._render();
  selectNode(tree, nextStepNode);
};
var deleteSelected_ = (tree, store) => {
  const indicesPerParent = selectedGroupedByParent(tree);
  for (let parentPath of Object.keys(indicesPerParent))
    pop(store, parentPath, indicesPerParent[parentPath].map((c) => c.index));
};
var cut = ({store, tree}) => {
  clearClipboard(tree);
  for (let a of tree.querySelectorAll("[aria-selected='true']"))
    a.classList.add("item-cutting");
  let selectedPerParent = selectedGroupedByParent(tree, {ops: ".item-cutting"});
  window._treeClipboard = {
    type: "cut",
    storeKey: store.key,
    ops: (dstPath) => popToRawSchs(store, selectedPerParent, {dstPath}),
    selected: selectedPerParent
  };
};
var copy = ({store, tree}) => {
  clearClipboard(tree);
  for (let a of tree.querySelectorAll("[aria-selected='true']"))
    a.classList.add("item-copying");
  let selectedPerParent = selectedGroupedByParent(tree, {ops: ".item-copying"});
  window._treeClipboard = {
    type: "copy",
    storeKey: store.key,
    ops: (dstPath) => copyToRawSchs(store, selectedPerParent, {dstPath, startIndex: 0}),
    selected: selectedPerParent
  };
};
var paste = ({tree, store, srcStore}) => {
  const dstSch = get(store, tree._walker.currentNode.id);
  if (![RECORD, UNION, TUPLE].includes(dstSch.type))
    return;
  if (window._treeClipboard) {
    const dstPath = tree._walker.currentNode.id;
    const {type, storeKey, ops, selected} = window._treeClipboard;
    let selectedPerParent = selected;
    let result = {};
    if (store.key == storeKey)
      switch (type) {
        case "copy":
          result = putSelected(store, {dstPath}, selectedPerParent);
          break;
        case "cut":
          result = move(store, {dstPath}, selectedPerParent);
          break;
      }
    else
      switch (type) {
        case "copy":
          let rawSchs = ops(dstPath);
          result = putSelectedRawSchs(store, {dstPath}, rawSchs);
          break;
        case "cut":
          let poppedPerSrc = ops(dstPath);
          result = putPoppedRawSchs(store, {dstPath}, poppedPerSrc);
          break;
      }
    if (Object.keys(result).length != 0) {
      tree._render();
      clearClipboard(tree);
      reselectNodes(tree, result);
    }
  }
};
var cloneUp = ({tree, store}) => cloneSelected({tree, store, direction: "up"}, (ascSelected) => ascSelected[0].index);
var cloneDown = ({tree, store}) => cloneSelected({tree, store, direction: "down"}, (ascSelected) => ascSelected[ascSelected.length - 1].index + 1);
var cloneSelected = ({tree, store, direction}, fStartIndex) => {
  let indicesPerParent = selectedGroupedByParent(tree);
  let result = {};
  for (let dstPath of Object.keys(indicesPerParent))
    result = putSelected(store, {dstPath, startIndex: fStartIndex(indicesPerParent[dstPath])}, {[dstPath]: indicesPerParent[dstPath]});
  if (Object.keys(result).length != 0) {
    tree._render();
    reselectNodes(tree, result, {direction});
  }
};
var reorderUp = ({tree, store}) => reorder({tree, store, startIndex: (i2) => i2 - 1, direction: "up"});
var reorderDown = ({tree, store}) => reorder({tree, store, startIndex: (i2) => i2 + 1, direction: "down"});
var reorder = ({tree, store, startIndex, direction}) => {
  const indicesPerParent = selectedGroupedByParent(tree);
  let moved = {};
  for (let dstPath of Object.keys(indicesPerParent)) {
    let ascSelected = indicesPerParent[dstPath].sort((a, b) => a.index - b.index);
    moved = move(store, {dstPath, startIndex: startIndex(ascSelected[0].index)}, indicesPerParent);
  }
  if (Object.keys(moved).length != 0) {
    tree._render();
    reselectNodes(tree, moved, {direction});
  }
};
var component = ({store, target, metaSelector, opts}) => {
  store.render = (s) => renderRoot(target, s || store, opts || {});
  store.render();
  let tree = document.querySelector(`${target} [role='tree']`);
  let metaContainer = document.querySelector(metaSelector);
  if (tree) {
    tree._aria = aria_tree_exports;
    tree._render = store.render;
    createWalker2(tree);
    tree.onkeydown = handleTreeKeydown(store, opts.treeKeyDownOpts);
    tree.onclick = handleTreeClick(store);
    let rootNode = tree._walker.nextNode();
    selectNode(tree, tree._walker.nextNode() || rootNode, {focus: opts.focus});
    if (metaSelector)
      tree._metaContainer = metaContainer;
    tree.renderSchMeta = () => renderSchMeta({tree, store});
    tree.renderSchMeta();
  }
};
var initFileView = ({store, target, metaSelector}) => {
  component({
    store,
    target,
    metaSelector,
    opts: {
      ui: {
        depthLimit: 2,
        modelTypeText: (sch, ui) => "file",
        typeText: (sch, ui) => {
          if (sch.type == RECORD)
            return "record";
          else if (sch.type == VALUE)
            return "value";
          else if (sch.type == TUPLE)
            return "tuple";
          else if (sch.type == UNION)
            return "union";
        },
        viewTypeRoot: (a) => ``
      },
      treeKeyDownOpts: {denyCmds: ["activateEditType", "copy", "cut", "paste"]},
      focus: true
    }
  });
};
var initModelView = ({store, target, metaSelector}) => {
  component({
    store,
    target,
    metaSelector,
    opts: {
      ui: {modelTypeText: (sch, ui) => "type"}
    }
  });
};
var update2 = ({store, detail, target}) => {
  let {path, attrs} = detail;
  let sch = update(store, path, (a, m) => save(a, attrs));
  store.render();
  renderMeta(target.closest("sch-meta"), sch, store);
};
export {
  project_exports as Project,
  allSchs,
  createStore,
  initFileView,
  initModelView,
  isContextSwitchedCmd,
  isModelChangedCmd,
  update2 as update
};
